# Code Review Findings

## âŒ Bugs / Incorrect Behavior
- **Leaderboard and dashboard can show stale scores after medal edits.** Admin medal updates (`/admin/medals`) overwrite medal totals and commit, but never trigger a score recomputation; the leaderboard and `total_points` cached on users therefore remain at old values until an admin manually clicks a separate "recalculate" endpoint or CLI command. There is no automatic recalculation in `admin_medals()` or `get_leaderboard()`, and even initial picks start with `total_points=0` until an admin intervenes. Tie-breaking and ranking can be wrong for long periods if medals are edited or added during the Games. Consider recalculating inside medal update transactions or computing on read. ã€F:app.pyâ€ L502-L540ã€‘ã€F:models.pyâ€ L200-L206ã€‘

## âš ï¸ Risky / Fragile
- **Game state singleton is not enforced at the database layer.** `GameState.get_instance()` simply returns `query.first()` or inserts a new row, but there is no uniqueness constraint to prevent multiple rows from being created (e.g., concurrent CLI calls or manual inserts). Any future queries relying on a single row could behave unpredictably depending on ordering. Add a unique check (e.g., enforce `id=1`, a table-level check constraint, or a one-row guarantee via database constraint). ã€F:models.pyâ€ L242-L260ã€‘
- **Tier multipliers can drift from stored picks if countries are retiered.** Picks cache `tier` on creation, but scoring pulls multipliers from the current `Country.tier`; retiering a country later silently changes usersâ€™ scores while leaving `Pick.tier` inconsistent. Depending on rule intent, either forbid retiering after lock or denormalize the multiplier/tier onto `Pick` and freeze it at pick time. ã€F:models.pyâ€ L184-L203ã€‘ã€F:models.pyâ€ L98-L118ã€‘

## ğŸ’¡ Suggested Improvements
- **Persist total picks and per-tier counts at the database level.** Validation in `validate_picks()` enforces counts in Python, but nothing stops direct inserts or race conditions from creating invalid rosters (wrong tier counts, too many picks). Add DB constraints or post-commit assertions (e.g., triggers or constrained unique indexes on `(user_id, tier)` with counts) to keep data consistent with the specificationâ€™s 8-pick distribution. ã€F:models.pyâ€ L93-L207ã€‘ã€F:SPECIFICATION.mdâ€ L34-L46ã€‘
- **Automate score updates when medals change.** To prevent stale data, wrap medal updates in a single transaction that also calls `calculate_all_scores()` and updates `GameState.scores_calculated_at`, or compute leaderboard points on the fly instead of relying on persisted `total_points`. Consider background jobs (Celery/APScheduler) if updates come from an external feed. ã€F:app.pyâ€ L502-L540ã€‘ã€F:models.pyâ€ L273-L305ã€‘
- **Improve medal ingestion safety.** `admin_medals()` overwrites counts without validation (negative numbers, regressions) or audit logging. Add non-negative checks, optimistic locking timestamps, and an idempotent import path if medal data will be synced repeatedly. Capturing per-update provenance would help rollback mistakes. ã€F:app.pyâ€ L506-L524ã€‘
- **Harden authentication for production.** The app ships with a hard-coded development `SECRET_KEY` and no password complexity/rate-limiting/captcha. Require `SECRET_KEY` and a stronger password policy in production config, and consider adding session cookie security flags. ã€F:config.pyâ€ L138-L179ã€‘
- **Rationalize country/tier sources.** `config.py`, `seed_data.py`, and `helpers.py` each carry their own country lists and mappings, risking drift (e.g., adding Tier 6 countries to one file but not others). Centralize canonical country/tier definitions in one module and import everywhere, or generate helper data from the DB. ã€F:config.pyâ€ L69-L132ã€‘ã€F:seed_data.pyâ€ L12-L146ã€‘ã€F:helpers.pyâ€ L5-L118ã€‘
- **Enforce pick visibility rules server-side in templates.** `/users` passes `show_picks` into the template, but templating should ensure only usernames are shown pre-deadline. Add server-side guards or omit pick data entirely before lock to avoid accidental leaks from future template changes. ã€F:app.pyâ€ L410-L424ã€‘
